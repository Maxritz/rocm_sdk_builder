From cdefd51da7fc5f107bbe07418207c5b4eac9be94 Mon Sep 17 00:00:00 2001
From: Jerry Mannil <65309407+jerrymannil@users.noreply.github.com>
Date: Wed, 30 Oct 2024 10:32:24 -0700
Subject: [PATCH 24/40] Remove vector length of 8 for half precision types for
 vectorized elementwise kernel (#1658)

Causing correctness issue due to vanishing gradients

It is a revert of part of a commit -
https://github.com/ROCm/pytorch/commit/8fc55a882669572852bf44d98609c207f252debe

---------

Co-authored-by: Akash Dutta <137309513+akadutta@users.noreply.github.com>
---
 aten/src/ATen/native/cuda/CUDALoops.cuh    |  5 -----
 aten/src/ATen/native/cuda/MemoryAccess.cuh | 22 +++++-----------------
 2 files changed, 5 insertions(+), 22 deletions(-)

diff --git a/aten/src/ATen/native/cuda/CUDALoops.cuh b/aten/src/ATen/native/cuda/CUDALoops.cuh
index 94417bae449..b8eb85fd4eb 100644
--- a/aten/src/ATen/native/cuda/CUDALoops.cuh
+++ b/aten/src/ATen/native/cuda/CUDALoops.cuh
@@ -116,11 +116,6 @@ static inline void launch_vectorized_kernel(
   int vec_size = memory::can_vectorize_up_to<func_t>(data);
 
   switch (vec_size) {
-    case 8:
-      vectorized_elementwise_kernel<8, func_t, array_t>
-          <<<grid, num_threads(), 0, stream>>>(N, f, data);
-      C10_CUDA_KERNEL_LAUNCH_CHECK();
-      break;
     case 4:
       vectorized_elementwise_kernel<4, func_t, array_t>
           <<<grid, num_threads(), 0, stream>>>(N, f, data);
diff --git a/aten/src/ATen/native/cuda/MemoryAccess.cuh b/aten/src/ATen/native/cuda/MemoryAccess.cuh
index 7144a7477d6..0fdc813fd77 100644
--- a/aten/src/ATen/native/cuda/MemoryAccess.cuh
+++ b/aten/src/ATen/native/cuda/MemoryAccess.cuh
@@ -350,23 +350,11 @@ inline C10_HOST_DEVICE int can_vectorize_up_to(const char *pointer) {
   uint64_t address = reinterpret_cast<uint64_t>(pointer);
   constexpr int vec2_alignment = std::alignment_of<aligned_vector<scalar_t, 2>>::value;
   constexpr int vec4_alignment = std::alignment_of<aligned_vector<scalar_t, 4>>::value;
-  #if defined(USE_ROCM)
-    constexpr int vec8_alignment = std::alignment_of<aligned_vector<scalar_t, 8>>::value;
-    constexpr bool half_dtype = std::is_same_v<c10::BFloat16, scalar_t> || std::is_same_v<c10::Half, scalar_t>;
-    if (half_dtype && (address % vec8_alignment == 0)) {
-      return 8;
-    } else if (address % vec4_alignment == 0) {
-      return 4;
-    } else if (address % vec2_alignment == 0) {
-      return 2;
-    }
-  #else
-    if (address % vec4_alignment == 0) {
-      return 4;
-    } else if (address % vec2_alignment == 0) {
-      return 2;
-    }
-  #endif
+  if (address % vec4_alignment == 0) {
+    return 4;
+  } else if (address % vec2_alignment == 0) {
+    return 2;
+  }
   return 1;
 }
 
-- 
2.43.0

